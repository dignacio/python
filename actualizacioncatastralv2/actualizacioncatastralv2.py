# -*- coding: utf-8 -*-
"""
/***************************************************************************
 actualizacioncatastralv2
                                 A QGIS plugin
 actualizacioncatastralv2
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2018-02-27
        git sha              : $Format:%H$
        copyright            : (C) 2018 by actualizacioncatastralv2
        email                : actualizacioncatastralv2
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, Qt, QSettings, QSize
from PyQt5.QtGui import QIcon, QColor, QCursor, QPixmap
from PyQt5.QtWidgets import QAction, QMessageBox
from PyQt5 import QtWidgets
from PyQt5 import QtGui
from PyQt5 import QtCore
# Initialize Qt resources from file resources.py
from .resources import *
from qgis.core import *
from qgis.utils import iface
from qgis.gui import QgsLayerTreeView

# Import the code for the DockWidget
from .actualizacioncatastralv2_dockwidget import actualizacioncatastralv2DockWidget
from .Cedula_MainWindow import CedulaMainWindow
import os.path
import os, json, requests
from osgeo import ogr, osr

class actualizacioncatastralv2:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'actualizacioncatastralv2_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&actualizacioncatastralv2')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'actualizacioncatastralv2')
        self.toolbar.setObjectName(u'actualizacioncatastralv2')

        #print "** INITIALIZING actualizacioncatastralv2"

        self.pluginIsActive = False
        self.dockwidget = None
        self.dockwidget = actualizacioncatastralv2DockWidget()

        self.dockwidget.setMinimumSize(QSize(359, 0))
        self.dockwidget.setMaximumSize(QSize(360, 1000))

        self.dockwidget.botonEditar.clicked.connect(self.actualizarFeature)
        self.dockwidget.botonActualizarRef.clicked.connect(self.actualizarFeatureRef)
        self.dockwidget.botonGuardarRef.clicked.connect(self.guardarCapaReferencia)
        self.dockwidget.botonCancelarReferencia.clicked.connect(self.rollbackCapa)
        self.dockwidget.botonCargar.clicked.connect(self.pintarCapas)
        self.dockwidget.comboLocalidad.currentIndexChanged.connect(self.obtenerSectoresPorLocalidad)
        self.dockwidget.comboSector.currentIndexChanged.connect(self.obtenerManzanasPorSector)
        self.dockwidget.comboManzana.currentIndexChanged.connect(self.obtenerIdManzana)
        self.dockwidget.botonCargarReferencia.clicked.connect(self.intermediarioReferencia)
        self.dockwidget.botonActivarEdicion.clicked.connect(self.activarEdicion)

        self.capaEnEdicion = None
        QSettings().setValue('capaRefEdicion', 'None')
        self.manzanaPrincipal = None
        self.tablasReferencias = {
        'Estado' : 'e_estado',
        'Region Catastral' : 'e_region_carto',
        'Municipios' : 'e_municipio',
        'Secciones' : 'e_seccion',		
        'Localidades' : 'e_localidad',
        'Sectores' : 'e_sector',
        'Manzanas' : 'e_manzana',
        'Predios' : 'e_predio',
        'Calles' : 'vw_calle',
        'Colonias' : 'e_colonia',
        'Codigo Postal' : 'e_cp',
        'Zona Uno' : 'e_zona_uno',
        'Zona Dos' : 'e_zona_dos',
        'Area de Valor' : 'e_area_valor'
        }

        # -- evento boton de abrir cedula --
        self.dockwidget.btnAbrirCedula.setIcon(QtGui.QIcon('add.png'))
        self.dockwidget.btnAbrirCedula.clicked.connect(self.abrirCedula)
        # -- evento boton de cancelar apertura de cedula --
        self.dockwidget.btnCancelAperCedula.clicked.connect(self.cancelarCedula)
        # -- canvas --
        self.canvas = iface.mapCanvas()
        # -- diseño del cursor --
        self.cursorRedondo = QCursor(QPixmap(["16 16 3 1",
                                "      c None",
                                ".     c #FF0000",
                                "+     c #FFFFFF",
                                "                ",
                                "       +.+      ",
                                "      ++.++     ",
                                "     +.....+    ",
                                "    +.     .+   ",
                                "   +.   .   .+  ",
                                "  +.    .    .+ ",
                                " ++.    .    .++",
                                " ... ...+... ...",
                                " ++.    .    .++",
                                "  +.    .    .+ ",
                                "   +.   .   .+  ",
                                "   ++.     .+   ",
                                "    ++.....+    ",
                                "      ++.++     ",
                                "       +.+      "]))
        # --  diseño del cursor --
        self.abrePredio = False
        # -- lista -- 
        self.dockwidget.lista = {}
        
    #Configuracion

    # -- metodo boton de abrir cedula --
    def abrirCedula(self):
        self.cambiarStatusCedula("Seleccione un predio...", "ok")
        self.iface.actionSelect().trigger()
        self.canvas.setCursor(self.cursorRedondo)
        self.dockwidget.btnAbrirCedula.setEnabled(False)
        self.abrePredio = True

    # -- metodo boton de cancelar apertura de cedula --
    def cancelarCedula(self):
        self.iface.actionSelect().trigger()
        self.dockwidget.btnAbrirCedula.setEnabled(True)
        self.abrePredio = False
        self.cambiarStatusCedula("Cancelado...", "")

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('actualizacioncatastralv2', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/actualizacioncatastralv2/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'actualizacioncatastralv2'),
            callback=self.run,
            parent=self.iface.mainWindow())

    #--------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING actualizacioncatastralv2"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False

        # -- desconectar los eventos -- 
        self.xManzana.selectionChanged.disconnect()
        self.xPredGeom.selectionChanged.disconnect()
        self.xPredNum.selectionChanged.disconnect()
        self.xConst.selectionChanged.disconnect()
        self.xHoriGeom.selectionChanged.disconnect()
        self.xHoriNum.selectionChanged.disconnect()
        self.xVert.selectionChanged.disconnect()
        self.xCvesVert.selectionChanged.disconnect()


########################################################################################################

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD actualizacioncatastralv2"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&actualizacioncatastralv2'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

 ########################################################################################################

    def run(self):
        """Run method that loads and starts the plugin"""

        self.obtenerXCapas()

        if self.capasCompletas():

            if not self.pluginIsActive:
                self.pluginIsActive = True

                #print "** STARTING actualizacioncatastralv2"

                # dockwidget may not exist if:
                #    first run of plugin
                #    removed on close (see self.onClosePlugin method)
                if self.dockwidget == None:
                    # Create the dockwidget (after translation) and keep reference
                    self.dockwidget = actualizacioncatastralv2DockWidget()

                # connect to provide cleanup on closing of dockwidget
                self.dockwidget.closingPlugin.connect(self.onClosePlugin)

                # show the dockwidget
                # TODO: fix to allow choice of dock location
                self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)
                

                self.cuerpo = {"incluirGeom": "true", "pagina": None, "bbox": "false", "pin": "false", "geomWKT": None, "epsg": None, "properties": None, "epsgGeomWKT": None, "itemsPagina": None, "nombre": "x"}
                self.headers = {'Content-Type': 'application/json'}
                self.payload = json.dumps(self.cuerpo)

                self.dockwidget.comboSector.clear()
                self.dockwidget.comboLocalidad.clear()
                self.dockwidget.comboManzana.clear()

                #Inicializacionde IdManzana
                self.idManzana = ' '

                #Modo desarrollor
                self.modoDesarrollo = True
                
                #Configuracion
                self.ip = 'http://192.168.0.40:8080/'
                self.urlManzanas = self.ip + 'busquedasimplewkn/api/manzana/'
                self.urlPrediosGeom = self.ip + 'busquedasimplewkn/api/manzana/predios/'
                self.urlPrediosNum = self.ip + 'busquedasimplewkn/api/busqueda/manzana/predios/'
                self.urlConstrucciones = self.ip + 'busquedasimplewkn/api/manzana/construcciones/'
                self.urlHorizontalesGeom = self.ip + 'busquedasimplewkn/api/manzana/deptoh/'
                self.urlHorizontalesNum = self.ip + 'busquedasimplewkn/api/busqueda/manzana/cond-horizontales/'
                self.urlVerticales = self.ip + 'busquedasimplewkn/api/manzana/deptov/'
                self.urlClavesV = self.ip + 'busquedasimplewkn/api/manzana/deptovcve/'
                self.urlTiposConst = self.ip + 'busquedasimplewkn/api/cat/const/esp/'
                
                #Acciones iniciales
                if self.modoDesarrollo:
                    self.obtenerIdManzana()
                    #self.pintarCapas()

                else:
                    try:
                        self.obtenerLocalidades()

                    except:
                        self.createAlert("Error al cargar localidades\nError de servidor", QMessageBox().Information, "Cargar Localidades")

                #Asignar eventos de cambio de seleccion
                

                self.xManzana.selectionChanged.connect(self.cargarTablita)
                self.xPredGeom.selectionChanged.connect(self.cargarTablita)
                self.xPredNum.selectionChanged.connect(self.cargarTablita)
                self.xConst.selectionChanged.connect(self.cargarTablita)
                self.xHoriGeom.selectionChanged.connect(self.cargarTablita)
                self.xHoriNum.selectionChanged.connect(self.cargarTablita)
                self.xVert.selectionChanged.connect(self.cargarTablita)
                self.xCvesVert.selectionChanged.connect(self.cargarTablita)

                self.dockwidget.comboCapasEdicion.setEnabled(True)
                self.dockwidget.botonActivarEdicion.setEnabled(True)
                self.dockwidget.botonActualizarRef.setEnabled(False)
                self.dockwidget.botonGuardarRef.setEnabled(False)
                self.dockwidget.botonCancelarReferencia.setEnabled(False)

                self.llenarComboReferencias()
                self.dockwidget.show()

        else:
            self.createAlert('No existen las capas necesarias para la consulta de manzanas', QMessageBox().Critical, 'Consulta de manzanas')
            return


#######################################################################################################################
    
    #validar posicion valida de combo
    def validarCombox(self):
        return (self.dockwidget.comboLocalidad.count() > 0 and self.dockwidget.comboSector.count() > 0 and self.dockwidget.comboManzana.count()) or self.modoDesarrollo

##########################################################################
    def obtenerIdManzana(self):
        
        
        #Obtener el identificador de la manzana
        if self.modoDesarrollo:
            #self.idManzana = '102800'  #Muchas manzanas
            #self.idManzana = '071061'  #Manzana corta
            #self.idManzana = '002055'  #Manzana estandar
            #self.idManzana = '030015'
            #self.idManzana = '065003'   #Manzana Estandar sin horizontales
            #self.idManzana = '102099'
            #self.idManzana = '060004'
            #self.idManzana = '009053'  #Manzana cortita y bonita
            #self.idManzana = '016031' #Disque sin condominios
            self.idManzana = '01001001020004060004'
            #self.idManzana = '01001001020004060004'
            #self.idManzana = '073999'
            #self.idManzana = '023042'
        else:
            index = self.dockwidget.comboManzana.currentIndex()
            self.idManzana = self.dockwidget.comboManzana.itemData(index)
            
        
########################################################################################################################

    #Llenar primer combo
    def obtenerLocalidades(self):

        self.dockwidget.comboLocalidad.clear()

        try:
            headers = {'Content-Type': 'application/json', 'Authorization' : self.obtenerToken()}
            respuesta = requests.get(self.ip + 'busquedasimplewkn/api/combo/001/localidades/', headers = headers)
        except requests.exceptions.RequestException:
            self.createAlert("Error de servidor", QMessageBox().Critical, "Cargar Localidades")
            print('ERROR: LOC000')

        lenJson = len(list(respuesta.json()))

        if lenJson > 0:
            for localidad in respuesta.json():
                self.dockwidget.comboLocalidad.addItem(str(localidad['label']) + " " + localidad['other'], str(localidad['value']) )
        else:
            self.createAlert("No existen localidades registradas", QMessageBox().Information, "Cargar Localidades")

#################################################################################################################################

    #Llenar segundo combo
    def obtenerSectoresPorLocalidad(self):

        if self.dockwidget.comboLocalidad.count() > 0:

            index = self.dockwidget.comboLocalidad.currentIndex()
            idSector = self.dockwidget.comboLocalidad.itemData(index)
            
            self.dockwidget.comboSector.clear()

            try:
                headers = {'Content-Type': 'application/json', 'Authorization' : self.obtenerToken()}
                
                respuesta = requests.get(self.ip +  'busquedasimplewkn/api/combo/localidades/' + idSector + '/sector/', headers = headers)
            except requests.exceptions.RequestException:
                self.createAlert("Error de servidor", QMessageBox().Critical, "Cargar Sectores")
                print('ERROR: SEC000')

            lenJson = len(list(respuesta.json()))

            if lenJson > 0:

                for sector in respuesta.json():

                    self.dockwidget.comboSector.addItem(sector['label'], sector['value']) #Cambiar value por label
            else:
                self.createAlert("No existen sectores en la localidad", QMessageBox().Information, "Cargar Sectores")
            

################################################################################################################################

    def llenarComboReferencias(self):
        self.dockwidget.comboCapaReferencia.clear()
        self.dockwidget.comboCapaReferencia.addItem('Estado', 'e_estado')
        self.dockwidget.comboCapaReferencia.addItem('Region Catastral', 'e_region_carto')
        self.dockwidget.comboCapaReferencia.addItem('Municipios', 'e_municipio')
        self.dockwidget.comboCapaReferencia.addItem('Secciones', 'e_seccion')
        self.dockwidget.comboCapaReferencia.addItem('Localidades', 'e_localidad')
        self.dockwidget.comboCapaReferencia.addItem('Sectores', 'e_sector')
        self.dockwidget.comboCapaReferencia.addItem('Manzanas', 'e_manzana')
        self.dockwidget.comboCapaReferencia.addItem('Predios', 'e_predio')
        self.dockwidget.comboCapaReferencia.addItem('Calles', 'vw_calle')
        self.dockwidget.comboCapaReferencia.addItem('Colonias', 'e_colonia')
        self.dockwidget.comboCapaReferencia.addItem('Codigo Postal', 'e_cp')
        self.dockwidget.comboCapaReferencia.addItem('Zona Uno', 'e_zona_uno')
        self.dockwidget.comboCapaReferencia.addItem('Zona Dos', 'e_zona_dos')
        self.dockwidget.comboCapaReferencia.addItem('Area de Valor', 'e_area_valor')


#################################################################################################################################
    #Llenar tercer combo
    def obtenerManzanasPorSector(self):
    
        if self.dockwidget.comboSector.count() > 0:

            index = self.dockwidget.comboSector.currentIndex()
            idSector = self.dockwidget.comboSector.itemData(index)

            self.dockwidget.comboManzana.clear()

            try:
                headers = {'Content-Type': 'application/json', 'Authorization' : self.obtenerToken()}
                respuesta = requests.get(self.ip +  'busquedasimplewkn/api/combo/sector/' + idSector + '/manzana/', headers = headers)
            except requests.exceptions.RequestException:
                self.createAlert("Error de servidor", QMessageBox().Critical, "Cargar Manzanas")
                print('ERROR: MAN000')

            lenJson = len(list(respuesta.json()))

            if lenJson > 0:
                for manzana in respuesta.json():
                    self.dockwidget.comboManzana.addItem(manzana['label'], manzana['other'])#Cambiar other por label
            else:
                self.createAlert("No existen manzanas en el sector", QMessageBox().Information, "Cargar Manzanas")

#####################################################################################################

    def intermediarioReferencia(self):
        nameCapa = self.dockwidget.comboCapaReferencia.currentText()

        try:
            bound = self.obtenerBoundingBox().asWkt()
        except:
            self.createAlert('No se ha cargado ninguna Manzana', QMessageBox().Critical, 'Cargar referencia')
            return

        if self.dockwidget.checkTodasGeom.isChecked():
            bound = None

        self.pintarCapasReferencia(nameCapa, bound, False)


##############################################################################################
    def obtenerToken(self):
        url= self.ip + '/auth/login'
        payload = {"username" : "user", "password" : "user"}
        payload = json.dumps(payload)
        headers = {'Content-Type': 'application/json'}

        response = requests.post(url, headers = headers, data = payload)
        if response.status_code == 200:
            #print('habemus token')
            data = response.content
        else:
            self.createAlert('Error de autenticacion', QMessageBox().Critical, 'Autenticacion')
            return
            ##print('no se arma el token')

        #print(json.loads(data)['access_token'])
        return 'bearer ' + json.loads(data)['access_token']

#####################################################################################################

    def obtenerBoundingBox(self):
        
        self.manzanaPrincipal = self.xManzana

        if self.manzanaPrincipal == None:
            return

        listaManzanas = list(self.manzanaPrincipal.getFeatures())
        geometria = QgsGeometry()

        rango = len(listaManzanas)
        geometria = listaManzanas[0].geometry()

        for i in range(0, rango):
            geometria = geometria.combine(listaManzanas[i].geometry())

        geoTemp = (QgsGeometry.fromWkt(geometria.boundingBox().asWktPolygon())).buffer(60, 0)

        return geoTemp


#####################################################################################################

    #Pintar todas las capas
    def pintarCapas(self):

        root = QgsProject.instance().layerTreeRoot()

        group = root.findGroup('ERRORES DE TOPOLOGIA')
        if not group is None:
            for child in group.children():
                dump = child.dump()
                id = dump.split("=")[-1].strip()
                QgsProject.instance().removeMapLayer(id)
            root.removeChildNode(group)

        #try:
        if self.validarCombox():

            self.vaciarCapa(self.xManzana)
            self.vaciarCapa(self.xPredGeom)
            self.vaciarCapa(self.xPredNum)
            self.vaciarCapa(self.xConst)
            self.vaciarCapa(self.xHoriGeom)
            self.vaciarCapa(self.xHoriNum)
            self.vaciarCapa(self.xVert)
            self.vaciarCapa(self.xCvesVert)

            if not self.pintarUnaCapa(self.xManzana):
                return
            self.zoomManzana()
            
            
            if not self.pintarUnaCapa(self.xPredGeom):
                return
            '''
            if not self.pintarNum(self.xPredNum):
                return
            
            if not self.pintarUnaCapa(self.xConst):
                return
            '''
            if not self.pintarUnaCapa(self.xHoriGeom):
                return
            '''
            if not self.pintarNum(self.xHoriNum):
                return
            '''
            if not self.pintarUnaCapa(self.xVert):
                return
            if not self.pintarUnaCapa(self.xCvesVert):
                return
            
            print ("Capas cargadas con exito")

        else:
            self.createAlert('No se han seleccionado manzanas para cargar', QMessageBox.Critical, 'Capas de consulta')


########################################################################################################

    def pintarUnaCapa(self, mem_layer):
        
        nombreCapa = mem_layer.name()
        print ("Cargando... " + nombreCapa)
    

        if mem_layer == None:
            self.createAlert('No existe la capa ' + str(nombreCapa), QMessageBox().Critical, 'Cargar capas')
            return False
        
        data = self.obtenerAPintar(mem_layer.id())


        type(data)
        srid = QSettings().value("srid")
        inSpatialRef = osr.SpatialReference()
        inSpatialRef.ImportFromEPSG(int(srid))
        outSpatialRef = osr.SpatialReference()
        outSpatialRef.ImportFromEPSG(int(srid))
        coordTrans = osr.CoordinateTransformation(inSpatialRef, outSpatialRef)
        if not bool(data):
            self.createAlert("Error de servidor", QMessageBox().Critical, "Cargar capa de consulta")
            print('ERROR: CAP000')

        #Obtenemos todos los atributos del JSON
        if data['features'] == []:
            print("ENTRO AQUI VATO")
            return True
        
        varKeys = data['features'][0]['properties']

        keys = list(varKeys.keys())
        properties = []
        geoms = []
        for feature in data['features']:

            geom = feature['geometry']
            
            property = feature['properties']
            geom = json.dumps(geom)
            geometry = ogr.CreateGeometryFromJson(geom)
            geometry.Transform(coordTrans)
            geoms.append(geometry.ExportToWkt())
            l = []
            for i in range(0, len(keys)):
                l.append(property[keys[i]])
            properties.append(l)

        prov = mem_layer.dataProvider()
        feats = [ QgsFeature() for i in range(len(geoms)) ]

        for i, feat in enumerate(feats):
            feat.setAttributes(properties[i])
            feat.setGeometry(QgsGeometry.fromWkt(geoms[i]))

        print("Constando: ", len(feats))
        prov.addFeatures(feats)

        mem_layer.triggerRepaint()
        return True

####################################################################################################

    def pintarNum(self, mem_layer):

        nombreCapa = mem_layer.name()
        print ("Cargando... " + nombreCapa)
    

        if mem_layer == None:
            self.createAlert('No existe la capa ' + str(nombreCapa), QMessageBox().Critical, 'Cargar capas')
            return False

        data = self.obtenerAPintar(mem_layer.id())

        etiquetaField = ""
        colorCapa = ""
        if mem_layer.id() == self.obtenerIdCapa("predios.num"):
            etiquetaField = "numExt"
            colorCapa = QColor(0,255,0)
        elif mem_layer.id() == self.obtenerIdCapa("horizontales.num"):
            etiquetaField = "numOfi"
            colorCapa = QColor(198,140,33)

        type(data)
        srid = QSettings().value("srid")
        inSpatialRef = osr.SpatialReference()
        inSpatialRef.ImportFromEPSG(int(srid))
        outSpatialRef = osr.SpatialReference()
        outSpatialRef.ImportFromEPSG(int(srid))
        coordTrans = osr.CoordinateTransformation(inSpatialRef, outSpatialRef)
        if not bool(data):
            return True
            #self.createAlert("Error de servidor", QMessageBox().Critical, "Cargar capa de consulta")
            #print('ERROR: NUM000')

        
        
        #Obtenemos todos los atributos del JSON
        polys = []
        listNum = []

        for feature in data:
            wkt = feature['geomNum']
            listNum.append(feature[etiquetaField])
            gem = QgsGeometry.fromWkt(wkt)
            polys.append(gem)

        mem_layer.startEditing()

        prov = mem_layer.dataProvider()
        feats = [ QgsFeature() for i in range(len(polys)) ]

        for i, feat in enumerate(feats):  
            feat.setGeometry(polys[i])
            prov.addFeature(feat)
            #feat[etiquetaField] = listNum[i]
            #mem_layer.updateFeature(feat)
            mem_layer.changeAttributeValue(feat.id(), 0, listNum[i])
            
        mem_layer.commitChanges()

        settings = QgsPalLayerSettings()
        settings.fieldName = etiquetaField
        settings.enabled = True
        settings.isExpression = False
        
        settings.centroidWhole = True

        textFormat = QgsTextFormat()
        textFormat.setColor(colorCapa)
        textFormat.setSize(8)
        textFormat.setNamedStyle('Bold')

        settings.setFormat(textFormat)

        #settings.placement= QgsPalLayerSettings.OverPoint
        labeling = QgsVectorLayerSimpleLabeling(settings)

        mem_layer.setLabeling(labeling)
        mem_layer.setLabelsEnabled(True)

        mem_layer.triggerRepaint()

        return True
        
#####################################################################################################

    def vaciarCapa(self, mem_layer):

        if mem_layer == None:
            return

        mem_layer.setReadOnly(False)
        #Obtenemos los fields antes de eliminar las features
        inFields = mem_layer.dataProvider().fields()
        #Habilitamos opcion de editado
        mem_layer.startEditing()
        #Iteramos para eliminar Features
        for f in mem_layer.getFeatures():
            mem_layer.deleteFeature(f.id())
        
        #Reasignamos los fields al VectorLayer
        mem_layer.dataProvider().addAttributes(inFields.toList())
        #Guardamos los cambios
        mem_layer.setReadOnly(True)
        mem_layer.commitChanges()

###################################################################################

    def zoomManzana(self):
    
        mem_layer = self.xManzana

        if mem_layer == None:
            return

        listaManzanas = list(mem_layer.getFeatures())
        geometria = QgsGeometry()

        rango = len(listaManzanas)
        geometria = listaManzanas[0].geometry()
        final = QgsGeometry()

        for i in range(0, rango):
            geometria = geometria.combine(listaManzanas[i].geometry())

        features = list(mem_layer.getFeatures())
        f = features[0]
        bbox = geometria.boundingBox()
        iface.mapCanvas().setExtent(bbox)
        iface.mapCanvas().refresh()

############################################################################################

    def obtenerAPintar(self, idCapa):

        url = ' '
        if self.traducirIdCapa(idCapa) == 'manzana':
            url = self.urlManzanas
        elif self.traducirIdCapa(idCapa) == 'predios.geom':
            url = self.urlPrediosGeom
        elif self.traducirIdCapa(idCapa) == 'predios.num':
            url = self.urlPrediosNum
        elif self.traducirIdCapa(idCapa) == 'construcciones':
            url = self.urlConstrucciones
        elif self.traducirIdCapa(idCapa) == 'horizontales.geom':
            url = self.urlHorizontalesGeom
        elif self.traducirIdCapa(idCapa) == 'horizontales.num':
            url = self.urlHorizontalesNum
        elif self.traducirIdCapa(idCapa) == 'verticales':
            url = self.urlVerticales
        elif self.traducirIdCapa(idCapa) == 'cves_verticales':
            url = self.urlClavesV

        #idManzana = self.dockwidget.comboManzana.currentText()
        try:
            headers = {'Content-Type': 'application/json', 'Authorization' : self.obtenerToken()}

            if self.traducirIdCapa(idCapa) == 'predios.num' or self.traducirIdCapa(idCapa) == 'horizontales.num':
                response = requests.get(url + self.idManzana, headers = headers)
            else:
                response = requests.post(url + self.idManzana, headers = headers, data = self.payload)



        except requests.exceptions.RequestException:
            self.createAlert("Error de servidor", QMessageBox().Critical, "Error de servidor")
            print('ERROR OAP000')
            return
        data = ""
        if response.status_code == 200:
            
            data = response.content

        else:
            self.createAlert('Error en peticion:\n' + response.text, QMessageBox().Critical, "Cargar capa")
            print('ERROR: CAP001')

        return json.loads(data)


        #Metodo que crea un elemento QMessageBox
    
#########################################################################################################
    
    def cargarTablita(self):
        
        self.capaActiva = iface.activeLayer()
        self.vaciarTablita()
        
        self.comboConstEsp = QtWidgets.QComboBox()

        header = self.dockwidget.tablaEdicion.horizontalHeader()
        header.setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeToContents)
        header.setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeToContents)
        #header.setStretchLastSection(True)
        
        self.dockwidget.labelCapaEdicion.setText('---')
        if self.capaActiva == None:
            #self.createAlert("No tienes ninguna capa activa", QMessageBox().Critical, 'Edicion de atributos')
            self.cambiarStatus("No se ha seleccionado ninguna capa", "error")

        else:

            self.seleccion = self.capaActiva.selectedFeatures()
            self.listaEtiquetas = []
            self.dockwidget.labelCapaEdicion.setText(self.traducirIdCapa( self.capaActiva.id()))
            
            if (len(self.seleccion) == 1):

                self.cambiarStatus("Edicion Activa", "ok")
                campos = self.capaActiva.fields()   
                nombres = [campo.name() for campo in campos]
                self.tipConst = 0

                if self.capaActiva.id() == self.obtenerIdCapa('manzana'):
                    self.listaAtributos = ['clave']
                    self.listaEtiquetas = ['Clave']
                elif self.capaActiva.id() == self.obtenerIdCapa('predios.geom'):
                    self.listaAtributos = ['clave']
                    self.listaEtiquetas = ['Clave']
                elif self.capaActiva.id() == self.obtenerIdCapa('predios.num'):
                    self.listaAtributos = ['numExt']
                    self.listaEtiquetas = ['Numero exterior']
                elif self.capaActiva.id() == self.obtenerIdCapa('construcciones'):
                    ixCveConstEsp = campos.lookupField('cve_const_esp')
                    self.tipConst = self.seleccion[0].attributes()[ixCveConstEsp]
                    headers = {'Content-Type': 'application/json', 'Authorization' : self.obtenerToken()}
                    respuesta = requests.get(self.urlTiposConst, headers = headers)
                    diccionarioConst = {}
                    if respuesta.status_code == 200:
                        for clave in respuesta.json():
                            self.comboConstEsp.addItem(str(clave['cveConstEsp']) + " - " + clave['descripcion'], str(clave['cveConstEsp']) )
                            diccionarioConst[clave['cveConstEsp']] = str(clave['cveConstEsp']) + " - " + clave['descripcion']
                    else:
                        self.createAlert("No se han podido cargar los tipos de construccion especial\nError de servidor", QMessageBox().Critical, "Cargar tipos de construccion especial")

                    if  self.tipConst != None:
                        self.listaAtributos = ['nom_volumen', 'cve_const_esp']
                        self.listaEtiquetas = ['Nombre de volumen', 'Tipo de construccion']
                    else:
                        self.listaAtributos = ['nom_volumen', 'num_niveles']
                        self.listaEtiquetas = ['Nombre de volumen', 'Numero de niveles']
                elif self.capaActiva.id() == self.obtenerIdCapa('horizontales.geom'):
                    self.listaAtributos = ['clave']
                    self.listaEtiquetas = ['Clave']
                elif self.capaActiva.id() == self.obtenerIdCapa('horizontales.num'):
                    self.listaAtributos = ['numOfi']
                    self.listaEtiquetas = ['Numero Oficial']
                elif self.capaActiva.id() == self.obtenerIdCapa('verticales'):
                    self.listaAtributos = ['clave']
                    self.listaEtiquetas = ['Clave']
                elif self.capaActiva.id() == self.obtenerIdCapa('cves_verticales'):
                    self.listaAtributos = ['clave']
                    self.listaEtiquetas = ['Clave']

                if self.capaActiva.id() == self.obtenerIdCapa('construcciones'):
                    for x in range(0, len(self.listaAtributos)):
                                
                        self.dockwidget.tablaEdicion.insertRow(x)
                        item = QtWidgets.QTableWidgetItem(self.listaEtiquetas[x])
                        self.dockwidget.tablaEdicion.setItem(x, 0 , item)#self.capaActual.getFeatures().attributes()[x])
                        item.setFlags( QtCore.Qt.ItemIsSelectable |  QtCore.Qt.ItemIsEnabled )
                        textoItem = str( self.seleccion[0][self.listaAtributos[x]])
                        #print(textoItem)
                        if self.tipConst != None: 
                            if x == 1:
                                self.dockwidget.tablaEdicion.setCellWidget(1,1,self.comboConstEsp)
                                textito = self.seleccion[0].attributes()[ixCveConstEsp]
                                index = self.comboConstEsp.findText(diccionarioConst[textito], QtCore.Qt.MatchFixedString)
                                if index >= 0:
                                    self.comboConstEsp.setCurrentIndex(index)
                            else:
                                print("ponemos ", textoItem)
                                self.dockwidget.tablaEdicion.setItem(x, 1 , QtWidgets.QTableWidgetItem(textoItem)) 
                        else:
                            self.dockwidget.tablaEdicion.setItem(x, 1 , QtWidgets.QTableWidgetItem(textoItem))
                else:
                    for x in range(0, len(self.listaAtributos)):
                                
                        self.dockwidget.tablaEdicion.insertRow(x)
                        item = QtWidgets.QTableWidgetItem(self.listaEtiquetas[x])
                        self.dockwidget.tablaEdicion.setItem(x, 0 , item)#self.capaActual.getFeatures().attributes()[x])
                        item.setFlags( QtCore.Qt.ItemIsSelectable |  QtCore.Qt.ItemIsEnabled )
                        textoItem = str( self.seleccion[0][self.listaAtributos[x]])
                        self.dockwidget.tablaEdicion.setItem(x, 1 , QtWidgets.QTableWidgetItem(textoItem))

            else:
                self.cambiarStatus("Debes seleccionar exactamente un elemento", "error")


        # -- abrir cedula -- 
        if self.abrePredio:

            listElim = []

            for key, value in self.dockwidget.lista.items():
                if self.dockwidget.lista[key].isVisible() == False:
                    listElim.append(key)

            for key in listElim:
                del self.dockwidget.lista[key]

            capaActiva = iface.activeLayer()
            features = []
            cond = False

            # saber cual capa esta activa, a cual se le dio click
            if capaActiva.id() == self.obtenerIdCapa('predios.geom'):
                features = self.xPredGeom.selectedFeatures()

                # validar si el predio contiene algun condominio
                condVCve = self.xCvesVert.getFeatures()
                condHori = self.xHoriGeom.getFeatures()

                # -- buscar si el predio seleccionado contiene condominios
                # -* ya sean verticales u horizontales
                for p in features:
                    geomP = p.geometry()

                    # verifica si tiene claves de verticales
                    for cv in condVCve:
                        geom = cv.geometry()
                        if geom.within(geomP):
                            cond = True
                            break

                    # verifica si tiene horizontales
                    for cv in condHori:
                        geom = cv.geometry().buffer(-0.000001,1)
                        if geom.within(geomP):
                            cond = True
                            break

            elif capaActiva.id() == self.obtenerIdCapa('horizontales.geom'):
                features = self.xHoriGeom.selectedFeatures()
                cond = True
            elif capaActiva.id() == self.obtenerIdCapa('cves_verticales'):
                features = self.xCvesVert.selectedFeatures()
                cond = True

            if len(features) == 0:
                self.cambiarStatusCedula("Seleccione una geometria", "error")
                return
            if len(features) != 1:
                self.cambiarStatusCedula("Seleccione una sola geometria", "error")
                return
            else:
                self.cambiarStatusCedula("Abriendo cedula...", "ok")

                feat = features[0]

                #validar si la clave ya existe
                for key, value in self.dockwidget.lista.items():
                    if str(key) == str(feat['cve_cat'][0:25]):
                        self.createAlert('La Clave: \'' + str(feat['cve_cat'][0:25]) + '\' se encuentra abierta', QMessageBox.Information, 'Cedula Catastral')
                        self.cancelaAperturaCedula()
                        return

                # limite de cedulas abiertas
                if len(self.dockwidget.lista) == 5:
                    self.createAlert('Excedio el limite de cedulas abiertas', QMessageBox().Warning, 'Cedula Catastral')
                    return

                # abrir Cedula
                self.dockwidget.lista[str(feat['cve_cat'])[0:25]] = CedulaMainWindow(str(feat['cve_cat']), cond = cond)
                self.dockwidget.lista[str(feat['cve_cat'])[0:25]].show()
                
            self.cancelaAperturaCedula()

    # -- funcion para cancelar la apertura de la cedula --
    def cancelaAperturaCedula(self):
        self.abrePredio = False
        self.dockwidget.btnAbrirCedula.setEnabled(True)

        self.xPredGeom.removeSelection()
        self.xHoriGeom.removeSelection()
        self.xCvesVert.removeSelection()
        self.canvas.refresh()
        # regresa herramienta de seleccion normal
        self.iface.actionSelect().trigger()
        self.cambiarStatusCedula("Listo...", "ok")


#########################################################################################################

    def actualizarFeature(self):

        if  self.dockwidget.tablaEdicion.rowCount() > 0:       

            if self.validarEdicion():
                
                self.createAlert('Se guardo correctamente', QMessageBox().Information, 'Edicion de atributos')
                self.cargarTablita()
            
        else:
            self.createAlert("Necesitas seleccionar una capa", QMessageBox.Warning, 'Edicion de atributos')

#############################################################################################################################

    def vaciarTablita(self):
        
        self.dockwidget.tablaEdicion.clearContents()
        self.dockwidget.tablaEdicion.setRowCount(0)
            
        for row in range(0, self.dockwidget.tablaEdicion.rowCount()):        
            self.dockwidget.tablaEdicion.removeRow(row) 

###########################################################################################################################

    def cargarTablitaRef(self):

        self.capaActiva = iface.activeLayer()
        self.vaciarTablitaRef()
        
        if self.capaActiva.id() == self.capaEnEdicion:

            self.comboTipoAs = QtWidgets.QComboBox()
            self.comboTipoVia = QtWidgets.QComboBox()

            self.comboTipoAs.clear()
            self.comboTipoVia.clear()

            idCapa = self.capaActiva.id()

            header = self.dockwidget.tablaEdicionRef.horizontalHeader()
            header.setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeToContents)
            header.setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeToContents)
            #header.setStretchLastSection(True)
            
            self.dockwidget.labelCapaEdicionRef.setText('---')



            if idCapa != self.obtenerIdCapa('Manzanas' )and idCapa != ('Predios'):

                self.seleccion = self.capaActiva.selectedFeatures()
                self.listaEtiquetas = []
                self.dockwidget.labelCapaEdicionRef.setText( self.traducirIdCapa( self.capaActiva.id()))
                
                if (len(self.seleccion) == 1):

                    self.cambiarStatusRef("Edicion Activa", "ok")
                    campos = self.capaActiva.fields()   
                    nombres = [campo.name() for campo in campos]
                    self.tipConst = 0

                    if self.capaActiva.id() == self.obtenerIdCapa('Area de Valor'): #Areas de valor
                        self.listaAtributos = ['valor', 'descripcion']
                        self.listaEtiquetas = ['Clave', 'Descripcion']

                    elif self.capaActiva.id() == self.obtenerIdCapa('Zona Uno') or self.capaActiva.id() == self.obtenerIdCapa('Zona Dos'): #Zonas
                        self.listaAtributos = ['descripcion']
                        self.listaEtiquetas = ['Descripcion']

                    elif self.capaActiva.id() == self.obtenerIdCapa('Predios'): #Zonas
                        self.listaAtributos = ['clave']
                        self.listaEtiquetas = ['Clave']

                    elif self.capaActiva.id() == self.obtenerIdCapa('Colonias'): #Codigo Postal
                        self.listaAtributos = ['cve_col', 'id_tipo_asentamiento', 'descripcion']
                        self.listaEtiquetas = ['Clave', 'Tipo de Asentamiento', 'Descripcion']

                        headers = {'Content-Type': 'application/json', 'Authorization' : self.obtenerToken()}

                        respuesta = requests.get('http://192.168.0.40:8080/configuracion/api/cat-tipo-asentamiento-humanos/', headers = headers)
                        self.comboTipoAs.addItem('Ninguno','NULL')
                        if respuesta.status_code == 200:
                            for resp in respuesta.json():
                                self.comboTipoAs.addItem(str(resp['descripcion']), str(resp['descripcion']))

                                textito = self.seleccion[0]['id_tipo_asentamiento']
                                index = self.comboTipoAs.findText(str(textito), QtCore.Qt.MatchFixedString)
                                if index >= 0:
                                    self.comboTipoAs.setCurrentIndex(index)
                        
                        else:
                            self.createAlert("No se han podido cargar los tipos de asentamiento\nError de servidor", QMessageBox().Critical, "Cargar tipos de asentamiento")


                    elif self.capaActiva.id() == self.obtenerIdCapa('Codigo Postal'): #Colonia
                        self.listaAtributos = ['cve_cp']
                        self.listaEtiquetas = ['CP']

                    elif self.capaActiva.id() == self.obtenerIdCapa('Calles'): #Calles
                        self.listaAtributos = ['valor', 'longitud', 'id_cve_vialidad', 'tipo_vector_calle', 'calle']
                        self.listaEtiquetas = ['Valor', 'Longitud', 'Clave vialidad', 'Tipo de Vector', 'Calle']

                        headers = {'Content-Type': 'application/json', 'Authorization' : self.obtenerToken()}

                        respuesta = requests.get('http://192.168.0.40:8080/configuracion/api/cat-vialidads/', headers = headers)
                        self.comboTipoVia.addItem('Ninguno','NULL')
                        if respuesta.status_code == 200:
                            for resp in respuesta.json():

                                self.comboTipoVia.addItem(str(resp['cTipoVialidad']), str(resp['id']))

                                textito = self.seleccion[0]['id_cve_vialidad']
                                index = self.comboTipoAs.findText(str(textito), QtCore.Qt.MatchFixedString)
                                if index >= 0:
                                    self.comboTipoAs.setCurrentIndex(index)
                        else:
                            self.createAlert("No se han podido cargar los tipos de asentamiento\nError de servidor", QMessageBox().Critical, "Cargar tipos de vialidad")


                    elif self.capaActiva.id() == self.obtenerIdCapa('Sectores'): #Sector
                        self.listaAtributos = ['clave', 'nombre']
                        self.listaEtiquetas = ['Clave', 'Nombre']
                    
                    elif self.capaActiva.id() == self.obtenerIdCapa('Localidades'): #Localidades
                        self.listaAtributos = ['clave', 'nombre']
                        self.listaEtiquetas = ['Clave', 'Nombre']
                    
                    elif self.capaActiva.id() == self.obtenerIdCapa('Secciones'): #Secciones
                        self.listaAtributos = ['clave', 'nombre']
                        self.listaEtiquetas = ['Clave', 'Nombre']

                    elif self.capaActiva.id() == self.obtenerIdCapa('Municipios'): #Municipios
                        self.listaAtributos = ['clave', 'nombre']
                        self.listaEtiquetas = ['Clave', 'Nombre']

                    elif self.capaActiva.id() == self.obtenerIdCapa('Region Catastral'): #Region Catastral
                        self.listaAtributos = ['clave', 'nombre']
                        self.listaEtiquetas = ['Clave', 'Nombre']

                    elif self.capaActiva.id() == self.obtenerIdCapa('Estado'): #Estado
                        self.listaAtributos = ['clave', 'nombre']
                        self.listaEtiquetas = ['Clave', 'Nombre']


                    for x in range(0, len(self.listaAtributos)):
                        self.dockwidget.tablaEdicionRef.insertRow(x)

                        item = QtWidgets.QTableWidgetItem(self.listaEtiquetas[x])
                        self.dockwidget.tablaEdicionRef.setItem(x, 0 , item)#self.capaActual.getFeatures().attributes()[x])
                        item.setFlags( QtCore.Qt.ItemIsSelectable |  QtCore.Qt.ItemIsEnabled )

                        textoItem = str( self.seleccion[0][self.listaAtributos[x]])

                        self.dockwidget.tablaEdicionRef.setItem(x, 1 , QtWidgets.QTableWidgetItem(textoItem))


                    if self.capaActiva.id() == self.obtenerIdCapa( 'Colonias'):

                        self.dockwidget.tablaEdicionRef.setCellWidget(1,1,self.comboTipoAs)

                    elif self.capaActiva.id() == self.obtenerIdCapa('Calles'):

                        textito = self.seleccion[0]['c_tipo_vialidad']
                        index = self.comboTipoVia.findText(str(textito), QtCore.Qt.MatchFixedString)
                        if index >= 0:
                            self.comboTipoVia.setCurrentIndex(index)
                        self.dockwidget.tablaEdicionRef.setCellWidget(2,1,self.comboTipoVia)
                        
                        longitud = self.seleccion[0].geometry().length()
                        item = QtWidgets.QTableWidgetItem(str(longitud))
                        item.setFlags( QtCore.Qt.ItemIsSelectable |  QtCore.Qt.ItemIsEnabled )
                        self.dockwidget.tablaEdicionRef.setItem(1, 1 , item)

                else:
                    self.cambiarStatusRef("Debes seleccionar exactamente un elemento", "error")

            else:
                self.cambiarStatusRef("No se permite editar la capa seleccionada", "error")

#########################################################################################################

    def actualizarFeatureRef(self):

        if  self.dockwidget.tablaEdicionRef.rowCount() > 0:       

            if self.validarEdicionRef():
                
                self.createAlert('Se guardo correctamente', QMessageBox().Information, 'Edicion de atributos')
                self.cargarTablitaRef()
            
        else:
            self.createAlert("Se requiere seleccionar exactamente un elemento a editar", QMessageBox.Warning, 'Edicion de atributos')

#############################################################################################################################

    def vaciarTablitaRef(self):
        
        self.dockwidget.tablaEdicionRef.clearContents()
        self.dockwidget.tablaEdicionRef.setRowCount(0)
            
        for row in range(0, self.dockwidget.tablaEdicionRef.rowCount()):        
            self.dockwidget.tablaEdicionRef.removeRow(row) 

####################################################################################################################


    def cambiarStatus(self, texto, estado):

        self.dockwidget.labelStatusEdicion.setText(texto)

        self.dockwidget.labelStatusEdicion.setAlignment(QtCore.Qt.AlignCenter | QtCore.Qt.AlignVCenter)
        
        if estado == "ok":
            estilo = """color: rgb(1, 230, 1);
font: 10pt "Bahnschrift";"""
        elif estado == "error":
            estilo = """color: rgb(255, 0, 0);
font: 10pt "Bahnschrift";"""
        elif estado == "warning":
            estilo = """color: rgb(255, 255, 0);
font: 10pt "Bahnschrift";"""

        self.dockwidget.labelStatusEdicion.setStyleSheet(estilo)

    def cambiarStatusCedula(self, texto, estado):

        self.dockwidget.lbEstatusCedula.setText(texto)

        if estado == "ok": # abriendo
            self.dockwidget.lbEstatusCedula.setStyleSheet('color: green')
        elif estado == "error": # Seleccione un solo predio
            self.dockwidget.lbEstatusCedula.setStyleSheet('color: red')
        else:
            self.dockwidget.lbEstatusCedula.setStyleSheet('color: black')


############################################################################################################################

    def cambiarStatusRef(self, texto, estado):

        self.dockwidget.labelStatusEdicionRef.setText(texto)

        self.dockwidget.labelStatusEdicionRef.setAlignment(QtCore.Qt.AlignCenter | QtCore.Qt.AlignVCenter)
        
        if estado == "ok":
            estilo = """color: rgb(1, 230, 1);
font: 10pt "Bahnschrift";"""
        elif estado == "error":
            estilo = """color: rgb(255, 0, 0);
font: 10pt "Bahnschrift";"""
        elif estado == "warning":
            estilo = """color: rgb(255, 255, 0);
font: 10pt "Bahnschrift";"""

        self.dockwidget.labelStatusEdicionRef.setStyleSheet(estilo)

##########################################################################################################


    def createAlert(self, mensaje, icono, titulo):
        #Create QMessageBox
        self.msg = QMessageBox()
        #Add message
        self.msg.setText(mensaje)
        #Add icon of critical error
        self.msg.setIcon(icono)
        #Add tittle
        self.msg.setWindowTitle(titulo)
        #Show of message dialog
        self.msg.show()
         # Run the dialog event loop
        result = self.msg.exec_()

#########################################################################################################################

    def validarEdicion(self):

        nombreCapa = self.traducirIdCapa( self.capaActiva.id())
        feat = self.capaActiva.selectedFeatures()[0]
        banderaCompleta = True
        self.capaActiva.startEditing()

        if nombreCapa == 'manzana':
            texto = "Nada"
            
            try:
                texto = self.dockwidget.tablaEdicion.item(0, 1).text()
            except: #Error al obtenre texto
                banderaCompleta = False
            if self.esEntero(texto): #Cuando es entero
                if len(texto) == 3: #Validacion de longitud
                    feat['clave'] = texto
                else:
                    banderaCompleta = False
            else: #Cuando no es numerico
                banderaCompleta = False
            
            if not banderaCompleta: #Mensaje de error
                self.createAlert('La clave debe estar compuesta por exactamente 3 numeros', QMessageBox().Critical, 'Error de entrada')

        #.....predios geom....#
        elif nombreCapa == 'predios.geom':
            texto = "Nada"
            
            try:
                texto = self.dockwidget.tablaEdicion.item(0, 1).text()
            except: #Error al obtenre texto
                banderaCompleta = False
            if self.esEntero(texto): #Cuando es entero
                if len(texto) == 5: #Validacion de longitud
                    feat['clave'] = texto
                else:
                    banderaCompleta = False
            else: #Cuando no es numerico
                banderaCompleta = False
            
            if not banderaCompleta: #Mensaje de error
                self.createAlert('La clave debe estar compuesta por exactamente 5 numeros', QMessageBox().Critical, 'Error de entrada')

        #.....predios geom....#
        elif nombreCapa == 'predios.num':
            texto = "Nada"
            
            try:
                texto = self.dockwidget.tablaEdicion.item(0, 1).text()
            except: #Error al obtenre texto
                banderaCompleta = False

            lenText = len(texto.strip())

            if lenText < 21 and lenText > 0: #Validacion de longitud
                feat['numExt'] = texto
            else:
                banderaCompleta = False

            if not banderaCompleta: #Mensaje de error
                self.createAlert('El numero oficial no debe exceder los 20 caracteres', QMessageBox().Critical, 'Error de entrada')
        
        #.....predios geom....#
        elif nombreCapa == 'horizontales.geom':
            texto = "Nada"
            
            try:
                texto = self.dockwidget.tablaEdicion.item(0, 1).text()
            except: #Error al obtenre texto
                banderaCompleta = False
            if self.esEntero(texto): #Cuando es entero
                if len(texto) == 6: #Validacion de longitud
                    feat['clave'] = texto
                else:
                    banderaCompleta = False
            else: #Cuando no es numerico
                banderaCompleta = False
            
            if not banderaCompleta: #Mensaje de error
                self.createAlert('La clave debe estar compuesta por exactamente 6 numeros', QMessageBox().Critical, 'Error de entrada')    

        #.....predios geom....#
        elif nombreCapa == 'horizontales.num':
            texto = "Nada"
            
            try:
                texto = self.dockwidget.tablaEdicion.item(0, 1).text()
            except: #Error al obtenre texto
                banderaCompleta = False

            lenText = len(texto.strip())
            if lenText < 21 and lenText > 0: #Validacion de longitud
                feat['numOfi'] = texto
            else:
                banderaCompleta = False
            
            if not banderaCompleta: #Mensaje de error
                self.createAlert('El numero oficial no debe exceder los 20 caracteres', QMessageBox().Critical, 'Error de entrada')

        #.....verticales geom....#
        elif nombreCapa == 'verticales':
            texto = "Nada"
            
            try:
                texto = self.dockwidget.tablaEdicion.item(0, 1).text()
            except: #Error al obtenre texto
                banderaCompleta = False
            if self.esEntero(texto): #Cuando es entero
                if len(texto) == 2: #Validacion de longitud
                    feat['clave'] = texto
                else:
                    banderaCompleta = False
            else: #Cuando no es numerico
                banderaCompleta = False
            
            if not banderaCompleta: #Mensaje de error
                self.createAlert('La clave debe estar compuesta por exactamente 2 numeros', QMessageBox().Critical, 'Error de entrada') 

        #.....clvaees verticales....#
        elif nombreCapa == 'cves_verticales':
            texto = "Nada"
            
            try:
                texto = self.dockwidget.tablaEdicion.item(0, 1).text()
            except: #Error al obtenre texto
                banderaCompleta = False
            if self.esEntero(texto): #Cuando es entero
                if len(texto) == 4: #Validacion de longitud
                    feat['clave'] = texto
                else:
                    banderaCompleta = False
            else: #Cuando no es numerico
                banderaCompleta = False
            
            if not banderaCompleta: #Mensaje de error
                self.createAlert('La clave debe estar compuesta por exactamente 4 numeros', QMessageBox().Critical, 'Error de entrada')


        elif nombreCapa == 'construcciones': #Con Construcciones

            bandera1 = True
              #Combo de construccion especial
            try:
                texto = self.dockwidget.tablaEdicion.item(0, 1).text()
                if len(texto) > 0 and len(texto) <=3:
                    feat['nom_volumen'] = texto
                else:
                    bandera1 = False
            except:
                bandera1 = False

            if not bandera1:
                self.createAlert('El nombre de volumen no debe exceder los 3 caracteres', QMessageBox().Critical, 'Error de entrada')
            
            bandera2 = True

            if feat['cve_const_esp'] != None:
                comboIndex2 = self.comboConstEsp.currentIndex()
                feat['cve_const_esp'] = self.comboConstEsp.itemData(comboIndex2)
                
            else:
                #try:
                texto = self.dockwidget.tablaEdicion.item(1, 1).text()
                
                if len(texto) > 0 and int(texto) < 999 and self.esEntero(texto):
                    feat['num_niveles'] = texto
                else:
                    bandera2 = False
                #except:
                #    bandera2 = False

            if not bandera2:
                self.createAlert('El numero de niveles debe ser numerico y no exceder 999', QMessageBox().Critical, 'Error de entrada')

            banderaCompleta = bandera1 and bandera2

        self.capaActiva.updateFeature(feat)
        self.capaActiva.triggerRepaint()
        self.capaActiva.commitChanges()

        return banderaCompleta

#####################################################################################################

    def validarEdicionRef(self):

        nombreCapa = self.traducirIdCapa( self.capaActiva.id())
        feat = self.capaActiva.selectedFeatures()[0]
        banderaCompleta = True

        self.capaActiva.setReadOnly(False)
        self.capaActiva.startEditing()

        #----------------------Area de valor------------------#
        if nombreCapa == 'Area de Valor':

            texto = "Nada"

            banderaValor = True

            try:
                texto = self.dockwidget.tablaEdicionRef.item(0, 1).text()
            except: #Error al obtenre texto
                banderaValor = False
            if self.esFloat(texto): #Cuando es entero
                if len(texto) < 12: #Validacion de longitud
                    feat['valor'] = float(texto)
                else:
                    banderaValor = False
            else: #Cuando no es numerico
                banderaValor = False
            
            banderaDesc = True

            try:
                texto = self.dockwidget.tablaEdicionRef.item(1, 1).text()
            except: #Error al obtenre texto
                banderaDesc = False
            if self.esFloat(texto): #Cuando es entero
                if len(texto) <= 256: #Validacion de longitud
                    feat['descripcion'] = texto
                else:
                    banderaDesc = False
            else: #Cuando no es numerico
                banderaDesc = False


            if not banderaValor:
                self.createAlert('El valor debe ser un numero decimal cuya longitud de texto no exceda 12 caracteres', QMessageBox().Critical, 'Error de entrada')

            if not banderaDesc:
                self.createAlert('La descripcion no debe exceder 256 caracteres', QMessageBox().Critical, 'Error de entrada')

            banderaCompleta = banderaValor and banderaDesc

        
        #----------------------Area de valor------------------#
        elif nombreCapa == 'Zona Uno':

            texto = "Nada"

            try:
                texto = self.dockwidget.tablaEdicionRef.item(0, 1).text()
            except: #Error al obtenre texto
                banderaCompleta = False
            if self.esFloat(texto): #Cuando es entero
                if len(texto) <= 50: #Validacion de longitud
                    feat['valor'] = float(texto)
                else:
                    banderaCompleta = False
            else: #Cuando no es numerico
                banderaCompleta = False
            
            if not banderaCompleta:
                self.createAlert('La descripcion no debe exceder 50 caracteres', QMessageBox().Critical, 'Error de entrada')

        #----------------------Area de valor------------------#
        elif nombreCapa == 'Zona Dos':

            texto = "Nada"

            try:
                texto = self.dockwidget.tablaEdicionRef.item(0, 1).text()
            except: #Error al obtenre texto
                banderaCompleta = False
            if self.esFloat(texto): #Cuando es entero
                if len(texto) <= 50: #Validacion de longitud
                    feat['descripcion'] = texto
                else:
                    banderaCompleta = False
            else: #Cuando no es numerico
                banderaCompleta = False
            
            if not banderaCompleta:
                self.createAlert('La descripcion no debe exceder 50 caracteres', QMessageBox().Critical, 'Error de entrada')

        #----------------------Codigo Postal------------------#
        elif nombreCapa == 'Codigo Postal':

            texto = "Nada"

            try:
                texto = self.dockwidget.tablaEdicionRef.item(0, 1).text()
            except: #Error al obtenre texto
                banderaCompleta = False
            if self.esEntero(texto): #Cuando es entero
                if len(texto) == 5: #Validacion de longitud
                    feat['cve_cp'] = texto
                else:
                    banderaCompleta = False
            else: #Cuando no es numerico
                banderaCompleta = False
            
            if not banderaCompleta:
                self.createAlert('El codigo postal debe estar compuesto por 5 numeros', QMessageBox().Critical, 'Error de entrada')

        #----------------------Codigo Postal------------------#
        elif nombreCapa == 'Colonias':

            texto = "Nada"

            banderaClave = True
            banderaDesc = True

            try:
                texto = self.dockwidget.tablaEdicionRef.item(0, 1).text()
            except: #Error al obtenre texto
                banderaClave = False
            if len(texto) == 4: #Validacion de longitud
                feat['cve_col'] = texto
            else:
                banderaClave = False

            
            try:
                texto = self.dockwidget.tablaEdicionRef.item(2, 1).text()
            except: #Error al obtenre texto
                banderaDesc = False
            if len(texto) <= 64: #Validacion de longitud
                feat['descripcion'] = texto
            else:
                banderaDesc = False

            if not banderaClave:
                self.createAlert('La longitud de la clave debe ser de 4 caracteres', QMessageBox().Critical, 'Error de entrada')

            if not banderaDesc:
                self.createAlert('La longitud de la descripcion no debe exceder 64 caracteres', QMessageBox().Critical, 'Error de entrada')

            banderaCompleta = banderaClave and banderaDesc

            if banderaCompleta:
                indexComboAs = self.comboTipoAs.currentIndex()
                feat['id_tipo_asentamiento'] = self.comboTipoAs.itemData(indexComboAs)

         #----------------------Codigo Postal------------------#
        
        #-------------------------Calles------------------------#
        elif nombreCapa == 'Calles':

            texto = "Nada"

            banderaTipo = True
            banderaCalle = True
            banderaValor = True

            #Comparar la clave
            try:
                texto = self.dockwidget.tablaEdicionRef.item(0, 1).text()
            except: #Error al obtenre texto
                banderaValor = False

            if self.esFloat(texto): #Cuando es entero
                if len(texto) < 12: #Validacion de longitud
                    #print(float(texto))
                    feat['valor'] = float(texto)
                    #print(feat['valor'])
                else:
                    banderaValor = False
            else: #Cuando no es numerico
                banderaValor = False


            try:
                texto = self.dockwidget.tablaEdicionRef.item(4, 1).text()
            except: #Error al obtenre texto
                banderaCalle = False
            if len(texto) <= 256: #Validacion de longitud
                feat['calle'] = texto
            else:
                banderaCalle = False

            
            try:
                texto = self.dockwidget.tablaEdicionRef.item(3, 1).text()
            except: #Error al obtenre texto
                banderaTipo = False
            if len(texto) <= 64: #Validacion de longitud
                feat['tipo_vector_calle'] = texto
            else:
                banderaTipo = False


            if not banderaValor:
                self.createAlert('El valor debe ser decimal y no exceder los 12 caracteres de longitud', QMessageBox().Critical, 'Error de entrada')

            if not banderaCalle:
                self.createAlert('La longitud de la calle no debe exceder 256 caracteres', QMessageBox().Critical, 'Error de entrada')

            if not banderaTipo:
                self.createAlert('La longitud del tipo de vector no debe exceder 64 caracteres', QMessageBox().Critical, 'Error de entrada')

            banderaCompleta = banderaValor and banderaTipo and banderaTipo

            if banderaCompleta:
                indexComboVia = self.comboTipoVia.currentIndex()
                feat['id_cve_vialidad'] = self.comboTipoVia.itemData(indexComboVia)
                feat['c_tipo_vialidad'] = self.comboTipoVia.currentText()
                feat['longitud'] = float(self.dockwidget.tablaEdicionRef.item(1, 1).text())


        #----------------------Codigo Postal------------------#
        elif nombreCapa == 'Sectores':

            texto = "Nada"

            banderaClave = True
            banderaNom = True

            #Comparar la clave
            try:
                texto = self.dockwidget.tablaEdicionRef.item(0, 1).text()
            except: #Error al obtenre texto
                banderaClave = False
            if self.esEntero(texto): #Cuando es entero
                if len(texto) == 3: #Validacion de longitud
                    feat['clave'] = texto
                else:
                    banderaClave = False
            else: #Cuando no es numerico
                banderaClave = False
            
            #Comparar el nombre
            try:
                texto = self.dockwidget.tablaEdicionRef.item(1, 1).text()
            except: #Error al obtenre texto
                banderaNom = False
            if len(texto) <= 256: #Validacion de longitud
                feat['nombre'] = texto
            else:
                banderaNom = False

            #Banderas
            if not banderaClave:
                self.createAlert('La clave debe estar compuesta por 3 numeros', QMessageBox().Critical, 'Error de entrada')

            if not banderaNom:
                self.createAlert('La longitud del nombre no debe exceder 256 caracteres', QMessageBox().Critical, 'Error de entrada')

            banderaCompleta = banderaClave and banderaNom

        #----------------------Codigo Postal------------------#
        elif nombreCapa == 'Localidades':

            texto = "Nada"

            banderaClave = True
            banderaNom = True

            #Comparar la clave
            try:
                texto = self.dockwidget.tablaEdicionRef.item(0, 1).text()
            except: #Error al obtenre texto
                banderaClave = False
            if self.esEntero(texto): #Cuando es entero
                if len(texto) == 4: #Validacion de longitud
                    feat['clave'] = texto
                else:
                    banderaClave = False
            else: #Cuando no es numerico
                banderaClave = False
            
            #Comparar el nombre
            try:
                texto = self.dockwidget.tablaEdicionRef.item(1, 1).text()
            except: #Error al obtenre texto
                banderaNom = False
            if len(texto) <= 256: #Validacion de longitud
                feat['nombre'] = texto
            else:
                banderaNom = False

            #Banderas
            if not banderaClave:
                self.createAlert('La clave debe estar compuesta por 4 numeros', QMessageBox().Critical, 'Error de entrada')

            if not banderaNom:
                self.createAlert('La longitud del nombre no debe exceder 256 caracteres', QMessageBox().Critical, 'Error de entrada')

            banderaCompleta = banderaClave and banderaNom

        #----------------------Codigo Postal------------------#
        elif nombreCapa == 'Secciones':

            texto = "Nada"

            banderaClave = True
            banderaNom = True

            #Comparar la clave
            try:
                texto = self.dockwidget.tablaEdicionRef.item(0, 1).text()
            except: #Error al obtenre texto
                banderaClave = False
            if self.esEntero(texto): #Cuando es entero
                if len(texto) == 2: #Validacion de longitud
                    feat['clave'] = texto
                else:
                    banderaClave = False
            else: #Cuando no es numerico
                banderaClave = False
            
            #Comparar el nombre
            try:
                texto = self.dockwidget.tablaEdicionRef.item(1, 1).text()
            except: #Error al obtenre texto
                banderaNom = False
            if len(texto) <= 64: #Validacion de longitud
                feat['nombre'] = texto
            else:
                banderaNom = False

            #Banderas
            if not banderaClave:
                self.createAlert('La clave debe estar compuesta por 2 numeros', QMessageBox().Critical, 'Error de entrada')

            if not banderaNom:
                self.createAlert('La longitud del nombre no debe exceder 64 caracteres', QMessageBox().Critical, 'Error de entrada')

            banderaCompleta = banderaClave and banderaNom

        #----------------------Codigo Postal------------------#
        elif nombreCapa == 'Municipios':

            texto = "Nada"

            banderaClave = True
            banderaNom = True

            #Comparar la clave
            try:
                texto = self.dockwidget.tablaEdicionRef.item(0, 1).text()
            except: #Error al obtenre texto
                banderaClave = False
            if self.esEntero(texto): #Cuando es entero
                if len(texto) == 3: #Validacion de longitud
                    feat['clave'] = texto
                else:
                    banderaClave = False
            else: #Cuando no es numerico
                banderaClave = False
            
            #Comparar el nombre
            try:
                texto = self.dockwidget.tablaEdicionRef.item(1, 1).text()
            except: #Error al obtenre texto
                banderaNom = False
            if len(texto) <= 256: #Validacion de longitud
                feat['nombre'] = texto
            else:
                banderaNom = False

            #Banderas
            if not banderaClave:
                self.createAlert('La clave debe estar compuesta por 3 numeros', QMessageBox().Critical, 'Error de entrada')

            if not banderaNom:
                self.createAlert('La longitud del nombre no debe exceder 256 caracteres', QMessageBox().Critical, 'Error de entrada')

            banderaCompleta = banderaClave and banderaNom

        #----------------------Codigo Postal------------------#
        elif nombreCapa == 'Region Catastral':

            texto = "Nada"

            banderaClave = True
            banderaNom = True

            #Comparar la clave
            try:
                texto = self.dockwidget.tablaEdicionRef.item(0, 1).text()
            except: #Error al obtenre texto
                banderaClave = False
            if self.esEntero(texto): #Cuando es entero
                if len(texto) == 3: #Validacion de longitud
                    feat['clave'] = texto
                else:
                    banderaClave = False
            else: #Cuando no es numerico
                banderaClave = False
            
            #Comparar el nombre
            try:
                texto = self.dockwidget.tablaEdicionRef.item(1, 1).text()
            except: #Error al obtenre texto
                banderaNom = False
            if len(texto) <= 64: #Validacion de longitud
                feat['nombre'] = texto
            else:
                banderaNom = False

            #Banderas
            if not banderaClave:
                self.createAlert('La clave debe estar compuesta por 3 numeros', QMessageBox().Critical, 'Error de entrada')

            if not banderaNom:
                self.createAlert('La longitud del nombre no debe exceder 64 caracteres', QMessageBox().Critical, 'Error de entrada')

            banderaCompleta = banderaClave and banderaNom

        #----------------------Codigo Postal------------------#
        elif nombreCapa == 'Estado':

            texto = "Nada"

            banderaClave = True
            banderaNom = True

            #Comparar la clave
            try:
                texto = self.dockwidget.tablaEdicionRef.item(0, 1).text()
            except: #Error al obtenre texto
                banderaClave = False
            if self.esEntero(texto): #Cuando es entero
                if len(texto) == 2: #Validacion de longitud
                    feat['clave'] = int(texto)
                else:
                    banderaClave = False
            else: #Cuando no es numerico
                banderaClave = False
            
            #Comparar el nombre
            try:
                texto = self.dockwidget.tablaEdicionRef.item(1, 1).text()
            except: #Error al obtenre texto
                banderaNom = False
            if len(texto) <= 64: #Validacion de longitud
                feat['nombre'] = texto
            else:
                banderaNom = False


            banderaCompleta = banderaClave and banderaNom

            #Banderas
            if not banderaClave:
                self.createAlert('La clave debe estar compuesta por 2 numeros', QMessageBox().Critical, 'Error de entrada')

            if not banderaNom:
                self.createAlert('La longitud del nombre no debe exceder 64 caracteres', QMessageBox().Critical, 'Error de entrada')

        self.capaActiva.updateFeature(feat)
        self.capaActiva.triggerRepaint()
        self.capaActiva.commitChanges()
        self.capaActiva.setReadOnly(False)
        return banderaCompleta

######################################################################################################

    def esEntero(self, num): #Funcion para checar si una variable es un entero numerico
        try: 
            int(num)
            return True
        except ValueError:
            return False

###################################################################################################

    def esFloat(self, num): #Funcion para checar si una variable es un entero numerico
        try: 
            float(num)
            return True
        except ValueError:
            return False
    
##########################################################################################################


    def pintarCapasReferencia(self, nameCapa, bound, edicion):
        #Nombre de la capa de acuerdo al valor del ComboBox de capas a cargar

        self.manzanaPrincipal = self.xManzana

        if self.manzanaPrincipal == None:
            self.createAlert("Debes cargar una manzana primero", QMessageBox().Critical, "Pintar capas de referencia")
            return


        if nameCapa == '':
            nameCapa = self.dockwidget.comboCapaReferencia.currentText()

        idCapa = self.obtenerIdCapa(nameCapa)
        capaAPintar = QgsProject.instance().mapLayer(idCapa)

        data = self.obtenerCapasDeReferencia(self.tablasReferencias[nameCapa], bound)

        vaciada = False

        if capaAPintar != None:
            if self.capaEnEdicion == self.obtenerIdCapa(nameCapa) and edicion == False:
                self.createAlert('La capa se encuentra en modo edicion, debes guardarla para volver a cargarla', QMessageBox().Critical, 'Cargar Capas')
            else:
                vaciada = True
                self.vaciarCapa(capaAPintar)

        if capaAPintar == None or edicion or vaciada:
            
            type(data)
            srid = 32614
            inSpatialRef = osr.SpatialReference()
            inSpatialRef.ImportFromEPSG(int(srid))
            outSpatialRef = osr.SpatialReference()
            outSpatialRef.ImportFromEPSG(int(srid))
            coordTrans = osr.CoordinateTransformation(inSpatialRef, outSpatialRef)
            if not bool(data):
                self.createAlert('Error de servidor', QMessageBox().Critical, "Cargar capa de referencia")
                print('ERROR: REF000')

            if data['features'] == []:
                return

            varKeys = data['features'][0]['properties']

            keys = list(varKeys.keys())
            properties = []
            geoms = []
            for feature in data['features']:
                geom = feature['geometry']
                
                property = feature['properties']
                geom = json.dumps(geom)
                geometry = ogr.CreateGeometryFromJson(geom)
                geometry.Transform(coordTrans)
                geoms.append(geometry.ExportToWkt())
                l = []
                for i in range(0, len(keys)):
                    l.append(property[keys[i]])
                properties.append(l)


            if nameCapa != 'Calles':    
                fields = ""
                for k in keys:
                    fields = fields + "&field=" + k + ":string(15)"

                uriFigura = 'Polygon'

                uri = str(uriFigura)+"?crs=epsg:" + str(srid) + fields + "&index=yes"

            else:
                stringCalles = self.obtenerCamposCalles()
                uri = stringCalles



            if capaAPintar == None:

                mem_layer = QgsVectorLayer(uri, nameCapa, 'memory')
                
            else:
                
                mem_layer = capaAPintar


            mem_layer.selectionChanged.connect(self.cargarTablitaRef)
            self.setearIdReferencia(nameCapa, mem_layer.id())

            mem_layer.setReadOnly(True)
            prov = mem_layer.dataProvider()
            feats = [ QgsFeature() for i in range(len(geoms)) ]
            for i, feat in enumerate(feats):
                feat.setAttributes(properties[i])
                feat.setGeometry(QgsGeometry.fromWkt(geoms[i]))

            

            if nameCapa != 'Manzanas' and nameCapa != 'Predios':
                prov.addFeatures(feats)
            
            else:
                for feat in feats:
                    bandera = True
                    for manzana in self.manzanaPrincipal.getFeatures():
                        if feat.geometry().intersects(manzana.geometry()):
                            bandera = False
                            break
                    if bandera:                
                        prov.addFeatures([feat])


            etiquetaField = ""

            if nameCapa == 'Estado':
                etiquetaField = 'nombre'
            elif nameCapa == 'Region Catastral':
                etiquetaField = 'clave'
            elif nameCapa == 'Municipios':
                etiquetaField = 'nombre'
            elif nameCapa == 'Secciones':
                etiquetaField = 'clave'
            elif nameCapa == 'Localidades':
                etiquetaField = 'nombre'
            elif nameCapa == 'Sectores':
                etiquetaField = 'nombre'
            elif nameCapa == 'Manzanas':
                etiquetaField = 'clave'
            elif nameCapa == 'Predios':
                etiquetaField = 'clave'
            elif nameCapa == 'Calles':
                etiquetaField = 'calle'
            elif nameCapa == 'Colonias':
                etiquetaField = 'descripcion'
            elif nameCapa == 'Codigo Postal':
                etiquetaField = 'cve_cp'
            elif nameCapa == 'Zona Uno':
                etiquetaField = 'clave'
            elif nameCapa == 'Zona Dos':
                etiquetaField = 'clave'
            elif nameCapa == 'Area de Valor':
                etiquetaField = 'valor'


            placeo = QgsPalLayerSettings.AroundPoint

            if nameCapa == 'Calles':
                placeo = QgsPalLayerSettings.Line  

            settings = QgsPalLayerSettings()
            settings.placement = placeo
            settings.fieldName = etiquetaField
            settings.enabled = True
            settings.isExpression = True
            
            settings.centroidWhole = True

            textFormat = QgsTextFormat()
            textFormat.setSize(8)
            textFormat.setNamedStyle('Bold')

            settings.setFormat(textFormat)

            #settings.placement= QgsPalLayerSettings.OverPoint
            labeling = QgsVectorLayerSimpleLabeling(settings)

            mem_layer.setLabeling(labeling)
            mem_layer.setLabelsEnabled(True)

            mem_layer.triggerRepaint()
            root = QgsProject.instance().layerTreeRoot()
            if not edicion:
                grupo = root.findGroup('referencia')
            else:
                grupo = root.findGroup('edicion')
                
                self.capaEnEdicion = self.obtenerIdCapa(nameCapa)
                QSettings().setValue('capaRefEdicion', self.capaEnEdicion)

            if not vaciada or edicion:
                QgsProject.instance().addMapLayers([mem_layer], False)
                
                mzaNL = QgsLayerTreeLayer(mem_layer)

                grupo.insertChildNode(0, mzaNL)



######################################################################################################

    def obtenerCapasDeReferencia(self, egName, bound):
        url='http://192.168.0.40:8080/busquedasimplewkn/api/busqueda/simple'

        index = self.dockwidget.comboCapaReferencia.currentIndex()

        token = self.obtenerToken()

        pagina = None
        itemsPagina = None

        if egName == 'e_predio':
            pagina = 0
            itemsPagina = 6000

        payload = {"nombre": egName, "epsg": 32614,"bbox": False,"pin": False,"geomWKT": bound, "epsgGeomWKT": 32614,"incluirGeom": True,"pagina": pagina,"itemsPagina": itemsPagina}
        payload = json.dumps(payload)
        headers = {'Content-Type': 'application/json', 'Authorization' : token}

        response = requests.post(url, headers = headers, data = payload)
        if response.status_code == 200:
            data = response.content
            data = json.loads(data)

            return data

        else:
            self.createAlert('Error de servidor', QMessageBox.Critical, 'Cargar capas de referencia')

##########################################################################################################
    
    def obtenerCamposCalles(self):

        headers = {'Content-Type': 'application/json', 'Authorization' : self.obtenerToken()}

        urlCapas = 'http://192.168.0.40:8080/busquedasimplewkn/api/thematics/lista/campos/sig:e_calle'
        respuesta = requests.post(urlCapas, headers = headers)
        
        stringCapa = "LineString?crs=epsg:" + str(QSettings().value('srid'))

        diccionarioTipo = {}
        diccionarioTipo["STRING"] = 'string'
        diccionarioTipo["INTEGER"] = 'integer'
        diccionarioTipo["DATETIME"] = 'date'
        diccionarioTipo["NUMERIC"] = 'real'
        diccionarioTipo["SMALLINT"] = 'integer'
        diccionarioTipo["BOOLEAN"] = 'string'

        if respuesta.status_code == 200:
            datos = respuesta.json()
            
            for campo in datos:

                longitud = campo['longitud']

                name = campo['name']
                tipo = diccionarioTipo[campo['type']]

                stringCapa += '&field='
                stringCapa += name + ':'
                stringCapa += tipo

                if longitud != None:
                    stringCapa += "("+str(longitud)+")"
                
            stringCapa += '&index=yes'
            return stringCapa
        else:
            print("obtenerCamposCalles", respuesta.status_code)

        

######################################################################################################################
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    def activarEdicion(self):
        

        try:
            bound = self.obtenerBoundingBox().asWkt()
        except:
            self.createAlert('No se ha cargado ninguna Manzana', QMessageBox().Critical, 'Cargar referencia')
            return

        nombreCapa = self.dockwidget.comboCapasEdicion.currentText()
        
        #try:
        #    bound = self.obtenerBoundingBox().asWkt()
        #except:
        #    self.createAlert('No se ha cargado ninguna Manzana', QMessageBox().Critical, 'Cargar referencia')
        #    return
        

        root = QgsProject.instance().layerTreeRoot()
        grupoEdicion = root.findGroup('edicion')
        cargar = False
        if grupoEdicion == None:
            root.insertGroup(0, 'edicion')
            grupoEdicion = root.findGroup('edicion')

        if len(list(grupoEdicion.children())) >= 1:
            if self.capaEnEdicion != nombreCapa:
                mensaje = "Quieres guardar?"
                respuesta = QMessageBox.question(iface.mainWindow(), "Nota de cambio de capa", mensaje, QMessageBox.Yes, QMessageBox.No)
            
                if respuesta == QMessageBox.No:
                    
                    group = root.findGroup('edicion')
                    if not group is None:
                        for child in group.children():
                            dump = child.dump()
                            id = dump.split("=")[-1].strip()
                            QgsProject.instance().removeMapLayer(id)
                    
                    self.quitarDeGrupo(self.capaEnEdicion, 'edicion')
                    self.quitarDeGrupo(self.obtenerIdCapa(nombreCapa), 'referencia')
                    self.pintarCapasReferencia(nombreCapa, None, True)
                    self.ineditarCampos(nombreCapa)
                    
                elif respuesta == QMessageBox.Yes:
                    
                    self.guardarCapaReferencia()
                    #self.quitarDeGrupo(self.capaEnEdicion, 'edicion')
                   # self.pintarCapasReferencia(self.capaEnEdicion, self.obtenerBoundingBox().asWkt(), False)
                    self.quitarDeGrupo(self.obtenerIdCapa(nombreCapa), 'referencia')
                    self.pintarCapasReferencia(nombreCapa, None, True)
                    self.ineditarCampos(nombreCapa)
            else:
                mensaje = "Quieres recargar la capa?"
                respuesta = QMessageBox.question(iface.mainWindow(), "Nota de cambio de capa", mensaje, QMessageBox.Yes, QMessageBox.No)

                if respuesta == QMessageBox.Yes:
                    group = root.findGroup('edicion')
                    if not group is None:
                        for child in group.children():
                            dump = child.dump()
                            id = dump.split("=")[-1].strip()
                            QgsProject.instance().removeMapLayer(id)
                    self.capaEnEdicion = nombreCapa
                    QSettings().setValue('capaRefEdicion', self.capaEnEdicion)
                    self.pintarCapasReferencia(nombreCapa, None, True)
                    self.quitarDeGrupo(self.obtenerIdCapa(nombreCapa), 'referencia')
                    self.ineditarCampos(nombreCapa)

        else:
            self.quitarDeGrupo(self.obtenerIdCapa(nombreCapa), 'referencia')
            self.pintarCapasReferencia(nombreCapa, None, True)
            #self.ineditarCampos(nombreCapa)

        self.dockwidget.comboCapasEdicion.setEnabled(False)
        self.dockwidget.botonActivarEdicion.setEnabled(False)
        self.dockwidget.botonActualizarRef.setEnabled(True)
        self.dockwidget.botonGuardarRef.setEnabled(True)
        self.dockwidget.botonCancelarReferencia.setEnabled(True)

##########################################################################################################

    def quitarDeGrupo(self, idCapa, nombreGrupo):

        root = QgsProject.instance().layerTreeRoot()
        grupo = root.findGroup(nombreGrupo)

        capa = QgsProject.instance().mapLayer(idCapa)
        if capa == None:
            return

        if nombreGrupo == 'edicion':

            capa.setReadOnly(True)

        for child in grupo.children():
            if child.name() == capa.name():
                dump = child.dump()
                id = dump.split("=")[-1].strip()
                QgsProject.instance().removeMapLayer(id)
                break

##################################################################################################

    def existeCapa(self, nombreCapa):
        capa = QgsProject.instance().mapLayer(nombreCapa)
        return capa != None
    
#########################################################################################

    def guardarCapaReferencia(self):

        #if nombreCapa == '':
        #    nombreCapa = self.capaEnEdicion
        if QSettings().value('posibleGuardarRef') == 'True':
            nombreCapa = self.capaEnEdicion
            capa = QgsProject.instance().mapLayer(self.capaEnEdicion)
            listaAGuardar = []

            if nombreCapa == '':
                nombreCapa = self.capaEnEdicion

            for feat in capa.getFeatures():
                campos = {}
                campos['geomWKT'] = feat.geometry().asWkt()
                campos['srid'] = 32614
                campos['nombre'] = self.tablasReferencias[self.traducirIdCapa( capa.id())]
                atributos = {}
                nombresAtrbutos = capa.fields()   

                nombres = [campo.name() for campo in nombresAtrbutos]

                for x in range(0, len(nombres)):
                    atributo = feat.attributes()[x]
                    if str(feat.attributes()[x]) == "NULL":
                        atributo = None
                    atributos[str(nombres[x])] = atributo
                    
                campos['propiedades'] = atributos
                if campos['propiedades']['id'] == None:
                    campos['accion'] = 'new'
                else:
                    campos['accion'] = 'update'
                listaAGuardar.append(campos)

            listaTempRef = QSettings().value('listaEliminadaRef')   
            for feat in listaTempRef:
                listaAGuardar.append(feat)

            jsonParaGuardarAtributos = json.dumps(listaAGuardar)

            print(jsonParaGuardarAtributos)
            url='http://192.168.0.40:6543/api/etables/'
            payload = jsonParaGuardarAtributos
            headers = {'Content-Type': 'application/json', 'Authorization' : self.obtenerToken()}
            
            
            try:
                response = requests.post(url, headers = headers, data = payload)
            
            except requests.exceptions.RequestException:
                self.createAlert("No se ha podido conectar al servidor v1", QMessageBox.Critical, "Guardar Cambios v1")#Error en la peticion de consulta
            
            print(response.status_code)
            if response.status_code == 200:
                self.createAlert("Cambios guardados con exito", QMessageBox.Information, "Guardar Cambios")
                QSettings().setValue('listaEliminadaRef', [])
                self.dockwidget.comboCapasEdicion.setEnabled(True)
                self.dockwidget.botonActivarEdicion.setEnabled(True)
                self.dockwidget.botonActualizarRef.setEnabled(False)
                self.dockwidget.botonGuardarRef.setEnabled(False)
                self.dockwidget.botonCancelarReferencia.setEnabled(False)
                self.quitarDeGrupo(self.capaEnEdicion, 'edicion')
                self.pintarCapasReferencia(self.traducirIdCapa( self.capaEnEdicion), self.obtenerBoundingBox().asWkt(), False)
                self.capaEnEdicion = ''
                QSettings().setValue('capaRefEdicion', self.capaEnEdicion)
        else:
            self.createAlert("Se debe validar la topologia de las capas de referencia antes de guardar", QMessageBox.Critical, "Guardar Cambios v1")#Error en la peticion de consulta
            

#####################################################################################################################

    def rollbackCapa(self):
        self.quitarDeGrupo(self.capaEnEdicion, 'edicion')
        #self.vaciarCapa(self.capaEnEdicion);
        traduccion = self.traducirIdCapa(self.capaEnEdicion)
        self.pintarCapasReferencia(traduccion, self.obtenerBoundingBox().asWkt(), False)
        self.dockwidget.comboCapasEdicion.setEnabled(True)
        self.dockwidget.botonActivarEdicion.setEnabled(True)
        self.dockwidget.botonActualizarRef.setEnabled(False)
        self.dockwidget.botonGuardarRef.setEnabled(False)
        self.dockwidget.botonCancelarReferencia.setEnabled(False)
        self.capaEnEdicion = ''
        QSettings().setValue('capaRefEdicion', self.capaEnEdicion)

##########################################################################################################################

    def ineditarCampos(self, nombreCapa):
        #Predios ineditables

        capa = QgsProject.instance().mapLayer(self.obtenerIdCapa(nombreCapa))
        capa.setReadOnly(False)
        campos = capa.fields()   
        nombres = [field.name() for field in campos]

        for i in range (0, len(nombres)):
            config = capa.editFormConfig()
            config.setReadOnly(i, True)
            capa.setEditFormConfig(config)

##########################################################################################################################

    def obtenerXCapas(self):
        xMan = QSettings().value('xManzana')
        xPredG = QSettings().value('xPredGeom')
        xPredN = QSettings().value('xPredNum')
        xCon = QSettings().value('xConst')
        xHoriG = QSettings().value('xHoriGeom')
        xHoriN = QSettings().value('xHoriNum')
        xVe = QSettings().value('xVert')
        xCv = QSettings().value('xCvesVert')

        self.xManzana = QgsProject.instance().mapLayer(xMan)
        self.xPredGeom = QgsProject.instance().mapLayer(xPredG)
        self.xPredNum = QgsProject.instance().mapLayer(xPredN)
        self.xConst = QgsProject.instance().mapLayer(xCon)
        self.xHoriGeom = QgsProject.instance().mapLayer(xHoriG)
        self.xHoriNum = QgsProject.instance().mapLayer(xHoriN)
        self.xVert = QgsProject.instance().mapLayer(xVe)
        self.xCvesVert = QgsProject.instance().mapLayer(xCv)


#####################################################################################################################

    def capasCompletas(self):
        if self.xManzana == None:
            return False
        if self.xPredGeom == None:
            return False
        if self.xPredNum == None:
            return False
        if self.xConst == None:
            return False
        if self.xHoriGeom == None:
            return False
        if self.xHoriNum == None:
            return False
        if self.xVert == None:
            return False
        if self.xCvesVert == None:
            return False
        return True

##########################################################################################################################

    def traducirIdCapa(self, idCapa):

        if QSettings().value('xManzana') == idCapa:
            return 'manzana'
        elif QSettings().value('xPredGeom') == idCapa:
            return 'predios.geom'
        elif QSettings().value('xPredNum') == idCapa:
            return 'predios.num'
        elif QSettings().value('xConst') == idCapa:
            return 'construcciones'
        elif QSettings().value('xHoriGeom') == idCapa:
            return 'horizontales.geom'
        elif QSettings().value('xHoriNum') == idCapa:
            return 'horizontales.num'
        elif QSettings().value('xVert') == idCapa:
            return 'verticales'
        elif QSettings().value('xCvesVert') == idCapa:
            return 'cves_verticales'

        elif QSettings().value('xAreaValor') == idCapa:
            return 'Area de Valor'
        elif QSettings().value('xZonaUno') == idCapa:
            return 'Zona Uno'
        elif QSettings().value('xZonaDos') == idCapa:
            return 'Zona Dos'
        elif QSettings().value('xCP') == idCapa:
            return 'Codigo Postal'
        elif QSettings().value('xColonia') == idCapa:
            return 'Colonias'
        elif QSettings().value('xCalle') == idCapa:
            return 'Calles'
        elif QSettings().value('xSector') == idCapa:
            return 'Sectores'
        elif QSettings().value('xLocal') == idCapa:
            return 'Localidades'
        elif QSettings().value('xSeccion') == idCapa:
            return 'Secciones'
        elif QSettings().value('xMunicipio') == idCapa:
            return 'Municipios'
        elif QSettings().value('xRegion') == idCapa:
            return 'Region Catastral'
        elif QSettings().value('xEstado') == idCapa:
            return 'Estado'

        return None

###########################################################################################################################
            
    def obtenerIdCapa(self, nombreCapa):

        if nombreCapa == "manzana":
            return QSettings().value('xManzana')
        elif nombreCapa == "predios.geom":
            return QSettings().value('xPredGeom')
        elif nombreCapa == "predios.num":
            return QSettings().value('xPredNum')
        elif nombreCapa == "construcciones":
            return QSettings().value('xConst')
        elif nombreCapa == "horizontales.geom":
            return QSettings().value('xHoriGeom')
        elif nombreCapa == "horizontales.num":
            return QSettings().value('xHoriNum')
        elif nombreCapa == "verticales":
            return QSettings().value('xVert')
        elif nombreCapa == "cves_verticales":
            return QSettings().value('xCvesVert')
        elif nombreCapa == "Area de Valor":
            return QSettings().value('xAreaValor')
        elif nombreCapa == "Zona Uno":
            return QSettings().value('xZonaUno')
        elif nombreCapa == "Zona Dos":
            return QSettings().value('xZonaDos')
        elif nombreCapa == "Codigo Postal":
            return QSettings().value('xCP')
        elif nombreCapa == "Colonias":
            return QSettings().value('xColonia')
        elif nombreCapa == "Calles":
            return QSettings().value('xCalle')
        elif nombreCapa == "Sectores":
            return QSettings().value('xSector')
        elif nombreCapa == "Localidades":
            return QSettings().value('xLocal')
        elif nombreCapa == "Secciones":
            return QSettings().value('xSeccion')
        elif nombreCapa == "Municipios":
            return QSettings().value('xMunicipio')
        elif nombreCapa == "Region Catastral":
            return QSettings().value('xRegion')
        elif nombreCapa == "Estado":
            return QSettings().value('xEstado')
        
        return 'None'

################################################################################################

    def setearIdReferencia(self, nombreCapa, idCapa):

        if nombreCapa == "Area de Valor":
            valor = 'xAreaValor'
        elif nombreCapa == "Zona Uno":
            valor = 'xZonaUno'
        elif nombreCapa == "Zona Dos":
            valor = 'xZonaDos'
        elif nombreCapa == "Codigo Postal":
            valor = 'xCP'
        elif nombreCapa == "Colonias":
            valor = 'xColonia'
        elif nombreCapa == "Calles":
            valor = 'xCalle'
        elif nombreCapa == "Sectores":
            valor = 'xSector'
        elif nombreCapa == "Localidades":
            valor = 'xLocal'
        elif nombreCapa == "Secciones":
            valor = 'xSeccion'
        elif nombreCapa == "Municipios":
            valor = 'xMunicipio'
        elif nombreCapa == "Region Catastral":
            valor = 'xRegion'
        elif nombreCapa == "Estado":
            valor = 'xEstado'
        elif nombreCapa == "Manzanas":
            valor = 'xManzanasRef'
        elif nombreCapa == "Predios":
            valor = 'xPredRef'

        QSettings().setValue(valor, idCapa)